use std::fmt::Debug;
use std::result::*;

mod ops;
mod ext;

pub use ops::*;
pub use ext::*;

pub enum Either<A, B> {A(A), B(B)}

/// common error format
#[derive(Debug, Clone, Copy)]
pub enum ComErr {
    /// (wanted, total)
    MemNotEnough(usize, usize),
    /// invalid access
    MemInvalidAccess,
    /// invalid input length
    FuncInvalidInputLength,
    /// invalid input meta
    FuncInvalidInputMeta,
    /// invalid input type
    FuncInvalidInputType,
    /// function not implemented
    FuncNotimplemented,
    /// device initialization failed
    InitFailure,
}

pub trait ArrayPrint {
    fn print(&self, shape: Vec<usize>) -> String 
    { todo!("ArrayPrint::print({shape:?})"); }
}

/// a device should be an internally mutable type
/// 
/// there are many symbols on a device. you can launch functions that read from and write to symbols. 
/// 
/// for some applications, you guarantee every symbol to be written only once
pub trait Device
where Self::Symbol: Debug + Eq + DTyped + Default, 
      Self::DatBox: Debug + ArrayPrint + From<Vec<f32>> + From<Vec<f64>> + From<Vec<i32>> + From<Vec<i64>> + From<Vec<u8>> + Into<Vec<u8>>, 
      Self::DevErr: Debug + Default, 
      Self: Debug + Clone + Sized, {

    /// symbol on device, models a flat vector of given data type
    /// 
    /// symbol type is immutable and should not implement Clone
    /// 
    /// default symbol should be empty i.e. of size 0
    type Symbol;

    /// data buffer on host, a unique reference with ownership like Box
    type DatBox;

    /// device specific error
    type DevErr;

    /// define a symbol on this device
    fn defn(&self, size: usize, ty: DType) -> Result<(), (ComErr, Self::DevErr)>
    { todo!("defn(size:{size:?}, ty:{ty:?})") }

    /// emit a function to this device, i.e. push a function to execution queue
    fn emit(&self, func: Func<Self::Symbol>) -> Result<(), (ComErr, Self::DevErr)>
    { todo!("emit({func:?})") }

    /// dump given symbol to a datbox, not consuming this symbol
    fn dump(&self, symbol: &Self::Symbol) -> Result<Self::DatBox, (ComErr, Self::DevErr)>
    { todo!("dupl({symbol:?})") }

    /// load given data to a new symbol, consuming this data, if a symbol is given, consume and return this symbol
    fn load(&self, datbox: Self::DatBox, symbol: &mut Self::Symbol) -> Result<(), (ComErr, Self::DevErr)>
    { todo!("load({datbox:?}, {symbol:?})") }

    /// drop a symbol without retrieving content
    fn drop(&self, symbol: Self::Symbol) -> Result<(), (ComErr, Self::DevErr)>
    { todo!("drop({symbol:?})") }
}

pub trait MemBridge<D0: Device, D1: Device>
where Self: Device {
    /// copy data from d0 to d1, default implementation is [d0 -> host -> d1]
    fn copy(d0: &D0, d1: &D1, s0: &D0::Symbol, s1: &mut D1::Symbol)
    -> Result<(), (ComErr, Either<D0::DevErr, D1::DevErr>)> {
        let data: Vec<u8> = match d0.dump(s0) {
            Err((ce, de)) => Err((ce, Either::A(de)))?,
            Ok(datbox) => datbox.into(),
        };
        match d1.load(data.into(), s1) {
            Err((ce, de)) => Err((ce, Either::B(de)))?,
            Ok(s1) => Ok(s1),
        }
    }
}

/// if we want to bundle many streams into one stream, unexpected failure cannot be avoided. (e.g. power failure)
/// 
/// to make our system self-recovery, we have to implement checkpointing and rollback mechanisms for a computation stream
pub trait DevLog
where Self: Device {
    /// return a checkpoint of current device
    fn ckpt(&self) -> Result<Vec<u8>, (ComErr, Self::DevErr)>;
    /// roll back to the given checkpoint, it returns ok(...) only if checkpoint is generated by the latest successful call on self.ckpt()
    fn roll(&self, ckpt: &Vec<u8>) -> Result<(), (ComErr, Self::DevErr)>;
}